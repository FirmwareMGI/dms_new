import logging
import string, random
import socket
import time
import binascii
import re
import helper
import tlv8
import enum
import mqtt as mqtt
from datetime import datetime
import db

client =None

logging.basicConfig(format="[DEBUG] %(filename)s >> %(funcName)20s():%(lineno)s - %(message)s",
    level=logging.DEBUG)

def BerDecoder_decodeLengthRecursive2(buffer,  bufPos,  maxBufPos,  depth,  maxDepth):

    if (bufPos >= maxBufPos):
        return -1
    
    len1 = buffer[bufPos]
    bufPos  += 1
    if (len1 & 0x80):
        lenLength = len1 & 0x7f

        if (lenLength == 0) :
            length = getIndefiniteLength(buffer, bufPos, maxBufPos, depth, maxDepth)
        
        else:
            length = 0
            i=0
            for i in range(lenLength):
                if (bufPos >= maxBufPos):
                    logging.error("bufpos > maxBufPos")
                    return -1, length

                if (bufPos + (length) > maxBufPos):
                    logging.error("bufpos+length>maxBufPos")
                    return -1, length

                length <<= 8
                length += buffer[bufPos]
                bufPos = bufPos + 1

    else:
        length = len1
    

    if (length < 0):
        logging.error("length<0")
        return -1, length

    if (length > maxBufPos):
        logging.error("length>maxBufPos")
        return -1, length

    if (bufPos + (length) > maxBufPos):
        logging.error("bufpos+length>maxBufPos")
        return -1, length

    return bufPos, length

def getIndefiniteLength(buffer,  bufPos,  maxBufPos,  depth,  maxDepth):

    depth=depth+1

    if (depth > maxDepth):
        return -1

    length = 0

    while (bufPos < maxBufPos):
        if ((buffer[bufPos] == 0) and ((bufPos + 1) < maxBufPos) and (buffer[bufPos+1] == 0)) :
            return length + 2
        
        else:
            length=length+1
            bufPos = bufPos +1
            if ((buffer[bufPos] & 0x1f) == 0x1f):
                length=length+1
                bufPos = bufPos +1

            subLength = -1
            newBufPos, subLength = BerDecoder_decodeLengthRecursive2(buffer, bufPos, maxBufPos, depth, maxDepth)

            if (newBufPos == -1):
                return -1
            length += subLength + newBufPos - bufPos

            bufPos = newBufPos + subLength
    return -1

def BerDecoder_decodeLength2(buffer, bufPos, maxBufPos):
    return BerDecoder_decodeLengthRecursive2(buffer, bufPos, maxBufPos, 0, 50)

def BerDecoder_decodeBoolean(buffer, bufPos):
    if (buffer[bufPos] != 0):
        return True
    else:
        return False

def BerDecoderUint32V2(buffer,  intLen, bufPos):
    value = 0
    i = 0
    for i in range(intLen):
        value <<= 8
        value += buffer[bufPos+i]
    return value

def parseIsoPresentationUserData(buffer):
    maxBufPos = len(buffer)
    hasAbstractSyntaxName = True
    bufPos = 0
    len0 = 0

    if (maxBufPos < 9):
        return 0, buffer
    
    if (buffer[bufPos] != 0x61):
        return 0, buffer

    bufPos+=1

    # print("buffer[%d] : %02X"%(bufPos, buffer[bufPos]))
    bufPos, len0 = BerDecoder_decodeLength2(buffer, bufPos, maxBufPos)
    # print("buffer[%d] : %02X len:%d"% (bufPos, buffer[bufPos], len0))

    if (bufPos < 0):
        logging.error("PRES: invalid message!");
        return 0, buffer

    if (buffer[bufPos] != 0x30):
        return 0, buffer
    
    bufPos+=1
        
    bufPos, len0 = BerDecoder_decodeLength2(buffer, bufPos, maxBufPos)
    if (bufPos < 0):
        logging.error("PRES: invalid message!");
        return 0, buffer
    
    while (bufPos < maxBufPos):
        tag = buffer[bufPos]
        bufPos += 1
        # print("tag : %02X" % buffer[bufPos])
        
        lenField = buffer[bufPos]
        # print("lenfield: %02X" %lenField)
        # print("bufposlast: %d"% bufPos)
        bufPos, len0 = BerDecoder_decodeLength2(buffer,  bufPos, maxBufPos)
        # print("bufposnext: %d"% bufPos)

        if (bufPos < 0):
            logging.error("PRES: wrong parameter length");
            return 0, buffer

        elif (tag==0x02): 
            # /* abstract-syntax-name */
            logging.error("0x02")
            nextContextId = buffer[bufPos]
            hasAbstractSyntaxName = True
            bufPos += len0

        elif (tag==0x06):
            # /* transfer-syntax-name */
            # /* check if basic-encoding (2.1.1 - 51 01) */
            logging.error("0x06")
            if ((buffer[bufPos] != 0x51) or (buffer[bufPos + 1] != 0x01)) :
                logging.error("PRES: unknown transfer-syntax-name")
                return 0, buffer
            bufPos += len

        elif (tag==0xa0): 
            # /* presentation data */
            logging.error("0xa0")
            if (hasAbstractSyntaxName == False):
                logging.error("PRES: abstract-syntax-name missing!\n")
                return 0, buffer
            userDataLength = len0
            if (lenField == 0x80):
                userDataLength = userDataLength - 2
                # ByteBuffer_wrap(&(self->nextPayload), buffer + bufPos, userDataLength, userDataLength)
            # print("buffer[%d]: %02X" % (bufPos,buffer[bufPos]))
            # print(bufPos)
            # print(userDataLength)
            buffer = buffer[bufPos:bufPos+userDataLength]
            return bufPos , buffer
    return 0, buffer

def handleMMSresponse(buffer, bufPos):
    
    if(buffer[bufPos]== 0xbf and buffer[bufPos+1]==0x4d):
        file, size, lastmodified = parseFileDirectory(buffer, bufPos, 1)
        buffer = [file]+[size]+[lastmodified]
        return 0x4d, buffer
    
    else:
        buffer = []
        return 0x00, buffer



def parseMMSPDU(buffer):
    buf = buffer
    maxPos = len(buffer)
    tag = buffer[0]
    if (tag == 0xa2):
        logging.error("confirmed error PDU")

    elif (tag == 0xa1):
        # { /* confirmed response PDU */
        # print("0xa1")
        length = 0
        bufPos = 1
        
        # print("prev == buffer[%d] : %02X len:%d"% (bufPos, buf[bufPos], length))
        bufPos, length = BerDecoder_decodeLength2(buf, bufPos, maxPos)
        # print("next == buffer[%d] : %02X len:%d"% (bufPos, buf[bufPos], length))

        if (bufPos < 0):
            return False
        
        if (buf[bufPos] == 0x02):
            bufPos+=1
            # print("0x02")
            invokeIdLength = 0
    
            bufPos, invokeIdLength  = BerDecoder_decodeLength2(buf, bufPos, maxPos)
 
            if (bufPos < 0):
                return False

            invokeId = BerDecoderUint32V2(buf, invokeIdLength, bufPos)
            bufPos += invokeIdLength

            code, buffParse = handleMMSresponse(buffer, bufPos)
            return code, buffParse
            

    elif(tag == 0xa0):
        # print("0xa0")
        bufPos = 1
        length = 0

        bufPos, length = BerDecoder_decodeLength2(buf, bufPos, maxPos);
        if (bufPos < 0):
            return False

        hasInvokeId = False
        invokeId = 0

        while (bufPos < maxPos):
            nestedTag = buf[bufPos]
            bufPos+=1
            extendedTag = False

            if ((nestedTag & 0x1f) == 0x1f):
                extendedTag = True
                nestedTag = buf[bufPos]
                bufPos+=1
            
            bufPos, length = BerDecoder_decodeLength2(buf, bufPos, maxPos)
            if (bufPos < 0):
                return False

            if (extendedTag):
                if (hasInvokeId == False):
                    logging.error("MMS_CLIENT: invalid message received - missing invoke ID!\n")

                if (nestedTag == 0x48): 
                    # /* file-open-request */
                    logging.error("file-open-request")
                    # ByteBuffer* response = IsoClientConnection_allocateTransmitBuffer(self->isoClient);
                    # mmsClient_handleFileOpenRequest(self, buf, bufPos, bufPos + length, invokeId, response);
                    # IsoClientConnection_sendMessage(self->isoClient, response);

                elif (nestedTag ==  0x49): 
                    # /* file-read-request */
                    logging.error("file-read-request")
                    # ByteBuffer* response = IsoClientConnection_allocateTransmitBuffer(self->isoClient);
                    # mmsClient_handleFileReadRequest(self, buf, bufPos, bufPos + length, invokeId, response);
                    # IsoClientConnection_sendMessage(self->isoClient, response);

                elif (nestedTag ==   0x4a): 
                    # /* file-close-request */
                    logging.error("file-close-request")
                    # ByteBuffer* response = IsoClientConnection_allocateTransmitBuffer(self->isoClient);
                    # mmsClient_handleFileCloseRequest(self, buf, bufPos, bufPos + length, invokeId, response);
                    # IsoClientConnection_sendMessage(self->isoClient, response);

            else:
                if (nestedTag == 0x02): #/* invoke Id */
                    invokeId = BerDecoderUint32V2(buf, length, bufPos)
                    hasInvokeId = True

                else:
                    # /*  mmsServer_writeMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_UNRECOGNIZED_SERVICE, response); */
                    logging.error("MMS_CLIENT: unexpected message from server!\n");
            bufPos += length
    else:
        logging.error("MMS_CLIENT: unknown message type\n");
    return True

def parseFileAttributes(buffer, bufPos, maxBufPos):
    fileSize= 0
    lastModified = 0
    endPos = maxBufPos
    length = 0
    while (bufPos < endPos):
        tag = buffer[bufPos]
        bufPos+=1
        bufPos, length = BerDecoder_decodeLength2(buffer, bufPos, endPos)
        if (bufPos < 0):
            return False

        if(tag == 0x80):
        # case 0x80: /* sizeOfFile */
            if (fileSize != None):
                fileSize = BerDecoderUint32V2(buffer, length, bufPos)
                # print("FileSize: %d" % fileSize)
            
        elif (tag==0x81):
        # case 0x81: /* lastModified */
            if (lastModified != None):
                gtString = buffer[bufPos:bufPos+length]
                # *lastModified = Conversions_generalizedTimeToMsTime(gtString);
                lastModified = ''.join(chr(i) for i in gtString)
                # print("FileModified: %s" % ''.join(chr(i) for i in lastModified))

        elif (tag==0x00):
        #case 0x00: /* indefinite length end tag -> ignore */
            logging.error("tag = 0x00 => IGNORE")
        else:
            return False
    
        bufPos += length

    return fileSize, lastModified


def parseDirectoryEntry(buffer, bufPos, maxBufPos, invokeId):

    fileNameMemory=[400]
    filename = None
    fileSize = 0
    lastModified = 0
    fileList = ''
    sizeList = []
    lastModifiedList = ''

    while (bufPos < maxBufPos):
        tag = buffer[bufPos]
        bufPos+=1
        length=0
        bufPos,length = BerDecoder_decodeLength2(buffer, bufPos, maxBufPos)
        if (bufPos < 0):
            return None, None, None
        
        if (tag==0xa0):
            #case 0xa0: /* file-name */
            logging.debug("tag: file-name")
            filename = fileNameMemory
            bufPos+=1
            tag = buffer[bufPos]
            bufPos, length = BerDecoder_decodeLength2(buffer, bufPos, maxBufPos)

            if (bufPos < 0):
               return None, None, None
      
            filename = buffer[bufPos:bufPos+length]
            fileList = ''.join(chr(i) for i in filename)
            # print("FileName: %s" % (''.join(chr(i) for i in filename)))
            # filename[length] = 0
            bufPos += length
        elif (tag==0xa1):
            #case 0xa1: /* file-attributes */
            # print("0xa1")
            logging.debug("tag: file-attributes")
            # if not (parseFileAttributes(buffer, bufPos, bufPos + length)):
            #     return False, fileList
            sizeList, lastModifiedList = parseFileAttributes(buffer, bufPos, bufPos + length)
            bufPos += length
        elif (tag==0x00):
        #case 0x00: /* indefinite length end tag -> ignore */
            # print("tag = 0x00 => IGNORE")
            logging.debug("tag: 0x00 IGNORE")
        else:
            bufPos += length
            return None, None, None 

    # if (filename != NULL)
    #     handler(invokeId, parameter, MMS_ERROR_NONE, filename, fileSize, lastModified, true);
    # else
    #     return false;

    return fileList, sizeList, lastModifiedList

def parseFileDirectory(buffer,bufPos,invokeID):
    state = False
    length = 0
    # bufPos = 0
    fileList =[]
    sizeList = []
    lastModifiedList = []
    maxBufPos = len(buffer)
    tag = buffer[bufPos]

    if(tag != 0xbf):
        return None, None, None

    bufPos += 1
    tag = buffer[bufPos]

    if (tag != 0x4d):
        return None, None, None

    bufPos += 1
    # print("prev == buffer[%d] : %02X len:%d"% (bufPos, buffer[bufPos], maxBufPos))
    bufPos, length = BerDecoder_decodeLength2(buffer, bufPos, maxBufPos)
    # print("next == buffer[%d] : %02X len:%d"% (bufPos, buffer[bufPos], length))

    if (bufPos < 0) :
        return None, None, None
    endPos = bufPos + length
    moreFollows = False

    while (bufPos < endPos):
        tag = buffer[bufPos]
        # print("tag: %02X"%tag)
        bufPos +=1

        bufPos , length = BerDecoder_decodeLength2(buffer, bufPos, maxBufPos)
       
        if (bufPos < 0): 
            return None, None, None

        if (tag == 0xa0): 
            # listOfDirectoryEntries #
            logging.error("listOfDirectoryEntries")
            fileList, sizeList ,lastModifiedList = parseListOfDirectoryEntries(buffer, bufPos, bufPos + length, invokeID)
            bufPos += length
            
        elif(tag== 0x81):
            # moreFollows #
            logging.error("moreFollows")
            moreFollows = BerDecoder_decodeBoolean(buffer, bufPos)
            bufPos += length;
            break;
        elif(tag==  0x00): 
            # indefinite length end tag -> ignore#
            break;
        else:
            bufPos += length

    return fileList, sizeList ,lastModifiedList

def parseListOfDirectoryEntries(buffer, bufPos, maxBufPos, invokeId):
    
    tag = buffer[bufPos]
    bufPos+=1
    # print("tag: %02X"%tag)
    if (tag != 0x30):
        return None, None, None

    length = 0
    fileNameList = []
    sizeList = []
    lastModifiedList = []

    # print("prev == buffer[%d] : %02X len:%d"% (bufPos, buffer[bufPos], maxBufPos))
    bufPos, length = BerDecoder_decodeLength2(buffer, bufPos, maxBufPos)
    # print("next == buffer[%d] : %02X len:%d"% (bufPos, buffer[bufPos], length))

    if (bufPos < 0) :
        return None, None, None

    endPos = bufPos + length

    while (bufPos < endPos):
        tag = buffer[bufPos]
        bufPos+=1

        bufPos,length = BerDecoder_decodeLength2(buffer, bufPos, maxBufPos)
        if (bufPos < 0): 
            return None, None, None

        if (tag==0x30):
            #case 0x30: /* Sequence */
            # logging.error("0x30")
            fileDir, sizeDir, lastModifDir = parseDirectoryEntry(buffer, bufPos, bufPos + length, invokeId)
            fileNameList.append(fileDir)
            sizeList.append(sizeDir)
            lastModifiedList.append(lastModifDir)
            # print(fileNameList)
            bufPos += length
        elif (tag==0x00):
        #case 0x00: /* indefinite length end tag -> ignore */
            logging.error("tag = 0x00 => IGNORE")
        else:
            bufPos += length
            return None, None, None

    return fileNameList , sizeList, lastModifiedList

def MMS_handleFileDirectory(prevList, fileName, fileSize, fileModified):
    listFile = []
    listFile = listFile + prevList
    return listFile


def coba_array(i,j, n):
    # rows, cols = (i, j)
    data_return = []
    for a in range(i):
        col = []
        for b in range(j):
            col.append(''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(n)))
        data_return.append(col)
    return data_return, data_return, data_return
if __name__ == '__main__':
    mqtt=mqtt.MQTT(0)
    if(client!=None):
            print("rekonnect mqtt")
            client.disconnect()
    mqttUser ="das"
    mqttPass= "mgi2022"
    broker = "203.194.112.238"
    port =1883
    try:
        client=mqtt.connect_mqtt(mqttUser,mqttPass,broker,port)
        client.loop_start()
    except:
        print("mqttNOtconnect")
    data_pres= [0x61,0x82,0x02,0x2b,0x30,0x82,0x02,0x27,0x02,0x01,0x03,0xa0,0x82,0x02,0x20,0xa1,0x82,0x02,0x1c,0x02,0x01,0x01,0xbf,0x4d,0x82,0x02,0x14,0xa0,0x82,0x02,0x10,0x30,0x82,0x02,0x0c,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x2e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x63,0x66,0x67,0xa1,0x15,0x80,0x02,0x02,0x0f,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x37,0x5a,0x30,0x48,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x2e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x64,0x61,0x74,0xa1,0x16,0x80,0x03,0x05,0xb8,0xf0,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x36,0x5a,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x02e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x74,0x78,0x74,0xa1,0x15,0x80,0x02,0x03,0x3e,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x39,0x5a,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x36,0x2e,0x30,0x36,0x2e,0x30,0x34,0x2e,0x38,0x33,0x30,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x63,0x66,0x67,0xa1,0x15,0x80,0x02,0x02,0x0f,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x33,0x35,0x38,0x30,0x34,0x5a,0x30,0x48,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x36,0x2e,0x30,0x36,0x2e,0x30,0x34,0x2e,0x38,0x33,0x30,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x64,0x61,0x74,0xa1,0x16,0x80,0x03,0x05,0xb8,0xf0,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x33,0x35,0x38,0x30,0x33,0x5a,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x36,0x2e,0x30,0x36,0x2e,0x30,0x34,0x2e,0x38,0x33,0x30,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x74,0x78,0x74,0xa1,0x15,0x80,0x02,0x03,0x3e,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x33,0x35,0x38,0x30,0x34,0x5a,0x30,0x52,0xa0,0x39,0x19,0x37,0x5c,0x4e,0x65,0x77,0x20,0x66,0x6f,0x6c,0x64,0x65,0x72,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x2e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x63,0x66,0x67,0xa1,0x15,0x80,0x02,0x02,0x0f,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x37,0x5a]
    data_filedirectory = [ 0xbf,0x4d,0x82,0x02,0x14,0xa0,0x82,0x02,0x10,0x30,0x82,0x02,0x0c,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x2e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x63,0x66,0x67,0xa1,0x15,0x80,0x02,0x02,0x0f,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x37,0x5a,0x30,0x48,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x2e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x64,0x61,0x74,0xa1,0x16,0x80,0x03,0x05,0xb8,0xf0,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x36,0x5a,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x02e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x74,0x78,0x74,0xa1,0x15,0x80,0x02,0x03,0x3e,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x39,0x5a,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x36,0x2e,0x30,0x36,0x2e,0x30,0x34,0x2e,0x38,0x33,0x30,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x63,0x66,0x67,0xa1,0x15,0x80,0x02,0x02,0x0f,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x33,0x35,0x38,0x30,0x34,0x5a,0x30,0x48,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x36,0x2e,0x30,0x36,0x2e,0x30,0x34,0x2e,0x38,0x33,0x30,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x64,0x61,0x74,0xa1,0x16,0x80,0x03,0x05,0xb8,0xf0,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x33,0x35,0x38,0x30,0x33,0x5a,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x36,0x2e,0x30,0x36,0x2e,0x30,0x34,0x2e,0x38,0x33,0x30,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x74,0x78,0x74,0xa1,0x15,0x80,0x02,0x03,0x3e,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x33,0x35,0x38,0x30,0x34,0x5a,0x30,0x52,0xa0,0x39,0x19,0x37,0x5c,0x4e,0x65,0x77,0x20,0x66,0x6f,0x6c,0x64,0x65,0x72,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x2e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x63,0x66,0x67,0xa1,0x15,0x80,0x02,0x02,0x0f,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x37,0x5a]
    
    data_setelah_parseawal = [0xa1,0x82,0x02,0x1c,0x02,0x01,0x01,0xbf,0x4d,0x82,0x02,0x14,0xa0,0x82,0x02,0x10,0x30,0x82,0x02,0x0c,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x2e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x63,0x66,0x67,0xa1,0x15,0x80,0x02,0x02,0x0f,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x37,0x5a,0x30,0x48,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x2e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x64,0x61,0x74,0xa1,0x16,0x80,0x03,0x05,0xb8,0xf0,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x36,0x5a,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x2e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x74,0x78,0x74,0xa1,0x15,0x80,0x02,0x03,0x3e,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x39,0x5a,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x36,0x2e,0x30,0x36,0x2e,0x30,0x34,0x2e,0x38,0x33,0x30,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x63,0x66,0x67,0xa1,0x15,0x80,0x02,0x02,0x0f,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x33,0x35,0x38,0x30,0x34,0x5a,0x30,0x48,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x36,0x2e,0x30,0x36,0x2e,0x30,0x34,0x2e,0x38,0x33,0x30,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x64,0x61,0x74,0xa1,0x16,0x80,0x03,0x05,0xb8,0xf0,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x33,0x35,0x38,0x30,0x33,0x5a,0x30,0x47,0xa0,0x2e,0x19,0x2c,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x36,0x2e,0x30,0x36,0x2e,0x30,0x34,0x2e,0x38,0x33,0x30,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x74,0x78,0x74,0xa1,0x15,0x80,0x02,0x03,0x3e,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x33,0x35,0x38,0x30,0x34,0x5a,0x30,0x52,0xa0,0x39,0x19,0x37,0x5c,0x4e,0x65,0x77,0x20,0x66,0x6f,0x6c,0x64,0x65,0x72,0x5c,0x30,0x31,0x2e,0x30,0x37,0x2e,0x32,0x30,0x32,0x31,0x20,0x30,0x35,0x2e,0x35,0x38,0x2e,0x32,0x36,0x2e,0x34,0x32,0x39,0x20,0x44,0x69,0x73,0x74,0x75,0x72,0x62,0x61,0x6e,0x63,0x65,0x2e,0x30,0x30,0x30,0x2e,0x63,0x66,0x67,0xa1,0x15,0x80,0x02,0x02,0x0f,0x81,0x0f,0x32,0x30,0x32,0x32,0x30,0x33,0x32,0x35,0x30,0x34,0x30,0x33,0x34,0x37,0x5a]
    state, buffer = parseIsoPresentationUserData(data_pres)
    code, parse = parseMMSPDU(buffer)
    ################################# array kirim #############################################
    init =[ 0x03, 0x00, 0x00, 0x16, 0x11, 0xe0, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc0, 0x01, 0x0d, 0xc2, 0x02, 0x00, 0x01, 0xc1, 0x02, 0x00, 0x01]
    initMMS=[0x03, 0x00, 0x00, 0xbb ,0x02 ,0xf0, 0x80 ,0x0d ,0xb2 ,0x05 ,0x06, 0x13 ,0x01 ,0x00 ,0x16 ,0x01,0x02,0x14,0x02,0x00,0x02,0x33,0x02,0x00,0x01,0x34,0x02,0x00,0x01,0xc1,0x9c,0x31,0x81,0x99,0xa0,0x03,0x80,0x01,0x01,0xa2,0x81,0x91,0x81,0x04,0x00,0x00,0x00,0x01,0x82,0x04,0x00,0x00,0x00,0x01,0xa4,0x23,0x30,0x0f,0x02,0x01,0x01,0x06,0x04,0x52,0x01,0x00,0x01,0x30,0x04,0x06,0x02,0x51,0x01,0x30,0x10,0x02,0x01,0x03,0x06,0x05,0x28,0xca,0x22,0x02,0x01,0x30,0x04,0x06,0x02,0x51,0x01,0x61,0x5e,0x30,0x5c,0x02,0x01,0x01,0xa0,0x57,0x60,0x55,0xa1,0x07,0x06,0x05,0x28,0xca,0x22,0x02,0x03,0xa2,0x07,0x06,0x05,0x29,0x01,0x87,0x67,0x01,0xa3,0x03,0x02,0x01,0x0c,0xa6,0x06,0x06,0x04,0x29,0x01,0x87,0x67,0xa7,0x03,0x02,0x01,0x0c,0xbe,0x2f,0x28,0x2d,0x02,0x01,0x03,0xa0,0x28,0xa8,0x26,0x80,0x03,0x00,0xfd,0xe8,0x81,0x01,0x05,0x82,0x01,0x05,0x83,0x01,0x0a,0xa4,0x16,0x80,0x01,0x01,0x81,0x03,0x05,0xf1,0x00,0x82,0x0c,0x03,0xee,0x1c,0x00,0x00,0x04,0x08,0x00,0x00,0x79,0xef,0x18]
    readData=[0x03, 0x00, 0x00, 0x58, 0x02, 0xf0, 0x80, 0x01, 0x00, 0x01, 0x00, 0x61, 0x4b, 0x30, 0x49, 0x02, 0x01, 0x03, 0xa0, 0x44, 0xa0, 0x42, 0x02, 0x02, 0x01, 0xf2, 0xa4, 0x3c, 0x80, 0x01, 0x00, 0xa1, 0x37, 0xa0, 0x35, 0x30, 0x33, 0xa0, 0x31, 0xa1, 0x2f]
    readDataOld=[0x03, 0x00, 0x00, 0x58, 0x02, 0xf0, 0x80, 0x01, 0x00, 0x01, 0x00, 0x61, 0x4b, 0x30, 0x49, 0x02, 0x01, 0x03, 0xa0, 0x44, 0xa0, 0x42, 0x02, 0x02, 0x01, 0xf2, 0xa4, 0x3c, 0x80, 0x01, 0x00, 0xa1, 0x37, 0xa0, 0x35, 0x30, 0x33, 0xa0, 0x31, 0xa1, 0x2f, 0x1a, 0x12, 0x53, 0x52, 0x47, 0x4e, 0x5f, 0x31, 0x4d, 0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x1a, 0x19, 0x53, 0x65, 0x63, 0x46, 0x6f, 0x75, 0x4d, 0x4d, 0x58, 0x55, 0x31, 0x24, 0x4d, 0x58, 0x24, 0x54, 0x6f, 0x74, 0x57, 0x24, 0x6d, 0x61, 0x67, 0x24,0x66]
    ##############################################################################
    ################################# koneksi ###############################
    domainId='SRGN_1Measurements'
    itemId ='SecFouMMXU1$MX$TotW$mag$f'
    # dataMeasurement=[
    #                 {"domainId":'SRGN_1Measurements','itemId':'PriRmsMMXU1$MX$A$phsA$cVal$mag$f'},
    #                 {"domainId":'SRGN_1Measurements','itemId':'PriRmsMMXU1$MX$A$phsB$cVal$mag$f'},
    #                 {"domainId":'SRGN_1Measurements','itemId':'PriRmsMMXU1$MX$A$phsC$cVal$mag$f'},
    #                  ]

    dataMeasurement=db.readDb.m_file_iec_read_by_active(0)
    #print(dataMeasurement)
    #host=[{'IP':"192.168.2.100"},{'IP':"localhost"}]
    dataDevice=db.readDb.device_list_by_mode(1)
    #print(dataDevice)
    #print(dataDevice[0]["ip_address"])
    client_socket=[]
    port = 102
    for i in range(len(dataDevice)):
        socketBuff= socket.socket()  # instantiate
        host=dataDevice[i]["ip_address"]
        socketBuff.connect((host, port))
        socketBuff.send(bytearray(init))
        data = socketBuff.recv(1024)
        print("--------------------------INIT CONN-------------------------------")
        #print(data)
        socketBuff.send(bytearray(initMMS))
        data = socketBuff.recv(1024)
        print("--------------------------INIT MMS-------------------------------")
        #print(data)
        client_socket.append(socketBuff)
    print(host)
    for i in range(len(dataMeasurement)):
        for j in range(len(dataDevice)):
            print(dataDevice[j]["id_device"])
            if(dataMeasurement[i]["id_device"]==dataDevice[j]["id_device"]):
                dataMeasurement[i]["dataSocket"]=j
    #print(dataMeasurement)
    #exit()
    #host = socket.gethostname()  # as both code is running on same pc
      # socket server port number
    # client_socket = socket.socket()  # instantiate
    # client_socket.connect((host, port))
    # client_socket.send(bytearray(init))
    
    # data = client_socket.recv(1024)
    # print("--------------------------INIT CONN-------------------------------")
    # print(data)
    # client_socket.send(bytearray(initMMS))
    # data = client_socket.recv(1024)
    
    
    flagDataMeasurement=0
    flagDataRelay=0
    dataMeasurementLength=len(dataMeasurement)
    while True:
        itemId= bytes(dataMeasurement[flagDataMeasurement]['item_id'],'UTF-8')
        domainId=bytes(dataMeasurement[flagDataMeasurement]['domain_id'],'UTF-8')
        id=dataMeasurement[flagDataMeasurement]['id_device']
        reqData=helper.iecHelper.convertRequest(readData,domainId,itemId)
        print("============================")
        dataSocket=dataMeasurement[flagDataMeasurement]['dataSocket']
        client_socket[dataSocket].send(bytearray(reqData))
        data = client_socket[dataSocket].recv(2048)
        tipeData= data[data.index(164)+4] #mencari tipe data setelah data a4
        #print(tipeData)
        dataOut=""
        dataType="Unknown"
        if(tipeData==135): #tipe data float
            dataOut = helper.iecHelper.parseDataFloat(data)    
            print(dataOut)
            dataType="float"
        elif(tipeData==138): #tipe data String
            lengthData= data[data.index(164)+5]
            dataOut = data[-data[data.index(164)+5]:]
            dataType="string"
            print(dataOut)
        elif(tipeData==145): #tipe data time
            lengthData= data[data.index(164)+5]
            dataString = data[-data[data.index(164)+5]:-4]
            buffHex=''.join('{:02x}'.format(x) for x in dataString)
            bufftime =int("0x"+buffHex, 0)
            dataOut = datetime.fromtimestamp(bufftime)
            dataType="Datetime"
            print(dataOut)
        elif(tipeData==134): #tipe data unsigned
            print(data)
            lengthData= data[data.index(164)+5]
            dataString = data[-data[data.index(164)+5]:]
            buffHex=''.join('{:02x}'.format(x) for x in dataString)
            dataOut =int("0x"+buffHex, 0)
            dataType="unsigned"
            print(dataOut)
        elif(tipeData==131): #tipe data Boolean
            print("boolean")
            dataBuf=data[data.index(164)+6]
            if(dataBuf==0):
                dataOut=False
            else:
                dataOut=True
            dataType="boolean"
            print(data)
        else:
            print(tipeData)
            print(data)
        dataJson={"alias":dataMeasurement[flagDataMeasurement]['alias'],"val":dataOut,"dataType":dataType}
        #send(self,client,topic,message)
        topic = f"DMS/0001/IEC61850/{id}/{dataMeasurement[flagDataMeasurement]['item_id']}/"
        #print(dataMeasurement[flagDataMeasurement]['device_id'])
        try:
            mqtt.send(client,topic,str(dataJson))
        except:
            ("mqtt not connect")
        flagDataMeasurement=flagDataMeasurement+1
        if(flagDataMeasurement>=dataMeasurementLength):
            flagDataMeasurement=0
        time.sleep(0.5)
        
    